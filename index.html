<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaTeX & BibTeX Tools</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 0.95em;
        }

        .tabs {
            display: flex;
            background: #f0f2ff;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            color: #667eea;
            border-bottom: 3px solid transparent;
        }

        .tab:hover {
            background: #e8ebff;
        }

        .tab.active {
            background: white;
            border-bottom: 3px solid #667eea;
            color: #764ba2;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 8px;
            padding: 60px 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            background: #f8f9ff;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: #764ba2;
            background: #f0f2ff;
            transform: scale(1.02);
        }

        .drop-zone-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .drop-zone-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 10px;
        }

        .file-info {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            display: none;
        }

        .file-info.visible {
            display: block;
        }

        .results {
            margin-top: 30px;
            display: none;
        }

        .results.visible {
            display: block;
        }

        .preview-section {
            margin-bottom: 25px;
        }

        .preview-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .mapping-list {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .mapping-item {
            display: flex;
            align-items: center;
            padding: 12px;
            margin-bottom: 10px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .mapping-item .old-name {
            flex: 1;
            color: #e74c3c;
            font-family: monospace;
            font-size: 0.9em;
        }

        .mapping-item .arrow {
            margin: 0 15px;
            color: #667eea;
            font-weight: bold;
        }

        .mapping-item .new-name {
            flex: 1;
            color: #27ae60;
            font-family: monospace;
            font-size: 0.9em;
            font-weight: bold;
        }

        .figures-drop-section {
            margin-top: 30px;
            padding: 25px;
            background: #fff9e6;
            border-radius: 8px;
            border: 2px solid #ffd700;
            display: none;
        }

        .figures-drop-section.visible {
            display: block;
        }

        .figures-drop-zone {
            border: 3px dashed #ffa500;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .figures-drop-zone:hover, .figures-drop-zone.drag-over {
            border-color: #ff8c00;
            background: #fffaf0;
            transform: scale(1.02);
        }

        .file-list {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .file-item .status {
            margin-right: 10px;
            font-size: 1.2em;
        }

        .file-item.matched {
            border-left: 3px solid #27ae60;
        }

        .file-item.unmatched {
            border-left: 3px solid #e74c3c;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 200px;
            padding: 15px 30px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #34495e;
            color: white;
        }

        .btn-secondary:hover {
            background: #2c3e50;
            transform: translateY(-2px);
        }

        .btn-zip {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            font-size: 1.1em;
        }

        .btn-zip:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .stat-card {
            flex: 1;
            min-width: 150px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .options {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .option {
            margin: 10px 0;
            display: flex;
            align-items: center;
        }

        .option input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .option label {
            color: #333;
            cursor: pointer;
            user-select: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .preview {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            display: none;
        }

        input[type="file"] {
            display: none;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #999;
            font-size: 0.85em;
            background: #f8f9fa;
        }

        .test-section {
            margin: 20px 0;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            border: 1px solid #ffeaa7;
        }

        .test-result {
            margin: 5px 0;
            padding: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .test-input {
            color: #e74c3c;
        }

        .test-output {
            color: #27ae60;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .main-container {
                margin: 10px;
            }

            .tab-content {
                padding: 20px;
            }

            .buttons {
                flex-direction: column;
            }

            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <header>
            <h1>üîß LaTeX & BibTeX Tools</h1>
            <p class="subtitle">Professional formatting tools for academic documents</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="figures">üìä Figure Organizer</div>
            <div class="tab" data-tab="bibtex">üìö BibTeX Formatter</div>
            <div class="tab" data-tab="test">üß™ Test Cases</div>
        </div>

        <div id="figures-tab" class="tab-content active">
            <div class="drop-zone" id="figuresDropZone">
                <div class="drop-zone-icon">üìÑ</div>
                <div class="drop-zone-text">Drag & drop your .tex file here</div>
                <div style="color: #999; font-size: 0.9em; margin-top: 10px;">or click to browse</div>
            </div>

            <input type="file" id="figuresFileInput" accept=".tex">

            <div class="file-info" id="figuresFileInfo">
                <strong>üìÅ File loaded:</strong> <span id="figuresFileName"></span>
            </div>

            <div class="results" id="figuresResults">
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="figureCount">0</div>
                        <div class="stat-label">Figures Found</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="imageCount">0</div>
                        <div class="stat-label">Images to Organize</div>
                    </div>
                </div>

                <div class="preview-section">
                    <h3>üìã File Organization Preview</h3>
                    <div class="mapping-list" id="mappingList"></div>
                </div>

                <div class="figures-drop-section" id="figuresDropSection">
                    <h3 style="color: #f39c12; margin-bottom: 15px;">üì¶ Drop Your Figure Files Here</h3>
                    <p style="color: #666; margin-bottom: 15px;">Drag your figure files **or folders** below to automatically rename and download them as a ZIP</p>
                    
                    <div class="figures-drop-zone" id="figuresFilesDropZone">
                        <div class="drop-zone-icon">üñºÔ∏è</div>
                        <div class="drop-zone-text">Drop image files or folders here</div>
                        <div style="color: #999; font-size: 0.9em; margin-top: 10px;">Supports: PNG, JPG, PDF, EPS, etc.</div>
                    </div>

                    <input type="file" id="figuresFilesInput" multiple accept="image/*,.pdf,.eps" webkitdirectory>

                    <div class="file-list" id="droppedFilesList"></div>

                    <button class="btn-zip" id="downloadZipButton" disabled>
                        <span>üì¶</span>
                        <span>Download Renamed Figures (ZIP)</span>
                    </button>
                </div>

                <div class="buttons">
                    <button class="btn-primary" id="downloadTex">
                        <span>‚¨áÔ∏è</span>
                        <span>Download Updated .tex</span>
                    </button>
                    <button class="btn-secondary" id="downloadBash">
                        <span>üêß</span>
                        <span>Bash Script (Mac/Linux)</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="bibtex-tab" class="tab-content">
            <div class="drop-zone" id="bibtexDropZone">
                <div class="drop-zone-icon">üìö</div>
                <div class="drop-zone-text">Drop your .bib or .bbl file here</div>
                <div style="color: #999; font-size: 0.9em; margin-top: 10px;">or click to browse</div>
            </div>

            <input type="file" id="bibtexFileInput" accept=".bib,.bbl">

            <div class="options">
                <div class="option">
                    <input type="checkbox" id="abbreviateAuthors" checked>
                    <label for="abbreviateAuthors">Abbreviate author names (e.g., "John Smith" ‚Üí "J. Smith")</label>
                </div>
                <div class="option">
                    <input type="checkbox" id="abbreviateJournals" checked>
                    <label for="abbreviateJournals">Abbreviate journal names</label>
                </div>
                <div class="option">
                    <input type="checkbox" id="removeDuplicates" checked>
                    <label for="removeDuplicates">Remove duplicate entries</label>
                </div>
            </div>

            <button class="btn-primary" id="bibtexProcessButton" disabled>Process File</button>

            <div class="stats" id="bibtexStats" style="display: none;"></div>

            <div class="status" id="bibtexStatus"></div>

            <div class="preview" id="bibtexPreview"></div>
        </div>

        <div id="test-tab" class="tab-content">
            <div class="test-section">
                <h3>üß™ Author Name Processing Test Cases</h3>
                <p>Testing the improved name formatting functions:</p>
                <div id="testResults"></div>
                <button class="btn-primary" id="runTestsButton">Run Tests</button>
            </div>
        </div>

        <footer>
            üîí All processing happens locally in your browser - no data is uploaded
        </footer>
    </div>

    <script>
    window.addEventListener('DOMContentLoaded', () => {

        // ===== TAB SWITCHING =====
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        // ===== IMPROVED BIBTEX FUNCTIONS =====
        function getInitials(name) {
            if (!name || name.trim() === '') return '';
            
            return name.trim().split(/\s+/).map(part => {
                if (part.includes('-')) {
                    return part.split('-').map(p => {
                        if (p.length === 0) return '';
                        return p.charAt(0).toUpperCase() + '.';
                    }).join('-');
                } else {
                    if (part.length === 0) return '';
                    return part.charAt(0).toUpperCase() + '.';
                }
            }).filter(Boolean).join(' ');
        }

        function formatAuthorName(author) {
            if (!author || author.trim() === '') return '';
            
            author = author.trim()
                .replace(/~/g, ' ')
                .replace(/\s+/g, ' ');
            
            if (author.startsWith('{') && author.endsWith('}')) {
                author = author.slice(1, -1);
            }
            
            const periodCount = (author.match(/\./g) || []).length;
            if (periodCount >= 2) {
                return author
                    .replace(/\.\s*\.\s*/g, '. ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }
            
            if (author.includes(',')) {
                const parts = author.split(',').map(p => p.trim());
                if (parts.length >= 2) {
                    const firstPart = parts[0];
                    const secondPart = parts[1];
                    
                    const journalIndicators = /[\[\]\(\)]|arXiv|doi|vol|pp|pages|et al\.|manuscript|preprint|submitted/i;
                    const seemsLikeFirstName = secondPart.length < 50 && !journalIndicators.test(secondPart);
                    
                    if (seemsLikeFirstName) {
                        const lastName = firstPart;
                        const firstNames = parts.slice(1).join(' ').trim();
                        if (firstNames) {
                            return `${getInitials(firstNames)} ${lastName}`;
                        }
                        return lastName;
                    } else {
                        author = firstPart;
                    }
                }
            }
            
            const parts = author.split(/\s+/).filter(Boolean);
            if (parts.length === 0) return '';
            if (parts.length === 1) return parts[0];
            
            const lastName = parts[parts.length - 1];
            const firstNames = parts.slice(0, -1).join(' ');
            
            return `${getInitials(firstNames)} ${lastName}`;
        }

        function formatAuthors(authorString) {
            if (!authorString || authorString.trim() === '') return '';
            
            const cleanAuthorString = authorString.replace(/^\{|\}$/g, '').trim();
            const authors = cleanAuthorString.split(/\s*\band\b\s*/i);
            
            return authors
                .map(author => formatAuthorName(author.trim()))
                .filter(Boolean)
                .join(' and ');
        }

        // ===== TEST FUNCTION =====
        function runTests() {
            const testCases = [
                'John Smith and Jane Doe',
                'Garc√≠a, Jos√© and M√ºller, Hans',
                'Jean-Pierre Dupont and Marie-Claire Dubois',
                'M. Talamali and V. Pet{\\"a}j{\\"a} and D. Vandembroucq and S. Roux'
            ];
            
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = '';
            
            testCases.forEach(testCase => {
                const result = formatAuthors(testCase);
                const div = document.createElement('div');
                div.className = 'test-result';
                div.innerHTML = `
                    <div class="test-input">Input:  ${testCase}</div>
                    <div class="test-output">Output: ${result}</div>
                    <hr style="margin: 10px 0;">
                `;
                resultsDiv.appendChild(div);
            });
        }
        
        document.getElementById('runTestsButton').addEventListener('click', runTests);

        // ===== FIGURE ORGANIZER SCRIPT =====
        (function() {
            let originalTexContent = '';
            let updatedTexContent = '';
            let mappings = [];
            let originalFileName = '';
            let droppedFiles = [];

            const dropZone = document.getElementById('figuresDropZone');
            const fileInput = document.getElementById('figuresFileInput');
            const fileInfo = document.getElementById('figuresFileInfo');
            const results = document.getElementById('figuresResults');
            const figuresDropSection = document.getElementById('figuresDropSection');
            const figuresFilesDropZone = document.getElementById('figuresFilesDropZone');
            const figuresFilesInput = document.getElementById('figuresFilesInput');
            const droppedFilesList = document.getElementById('droppedFilesList');
            const downloadZipButton = document.getElementById('downloadZipButton');

            // Safety check: if elements don't exist, log an error and stop
            if (!dropZone || !figuresFilesDropZone) {
                console.error("Fatal Error: Drop zones not found. Script cannot run.");
                return;
            }

            // *** NEW: Recursive function to traverse folders ***
            async function traverseEntry(entry, path, allFiles) {
                if (entry.isFile) {
                    try {
                        const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
                        // We manually add the relative path, so it matches the input's webkitRelativePath
                        file.webkitRelativePath = path + file.name;
                        allFiles.push(file);
                    } catch (err) {
                        console.error("Error reading file:", entry.name, err);
                    }
                } else if (entry.isDirectory) {
                    const reader = entry.createReader();
                    try {
                        const entries = await new Promise((resolve, reject) => reader.readEntries(resolve, reject));
                        const promises = [];
                        for (const childEntry of entries) {
                            promises.push(traverseEntry(childEntry, path + entry.name + '/', allFiles));
                        }
                        await Promise.all(promises);
                    } catch (err) {
                         console.error("Error reading directory:", entry.name, err);
                    }
                }
            }

            // *** NEW: Helper to process dropped items (files or folders) ***
            async function getFilesFromDrop(items) {
                const allFiles = [];
                const promises = [];
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.webkitGetAsEntry) {
                        const entry = item.webkitGetAsEntry();
                        if (entry) {
                            promises.push(traverseEntry(entry, '', allFiles));
                        }
                    }
                }
                await Promise.all(promises);
                return allFiles;
            }

            // --- .tex file drop zone ---
            dropZone.addEventListener('click', () => fileInput.click());

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
                
                // Check if files exist and there's at least one
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file && file.name.endsWith('.tex')) {
                        handleFile(file);
                    } else {
                        alert('Please drop a .tex file');
                    }
                } else {
                     alert('Please drop a .tex file');
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleFile(file);
            });

            // --- Figure files/folders drop zone ---
            figuresFilesDropZone.addEventListener('click', () => figuresFilesInput.click());

            figuresFilesDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                figuresFilesDropZone.classList.add('drag-over');
            });

            figuresFilesDropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                figuresFilesDropZone.classList.remove('drag-over');
            });

            // *** MODIFIED: Updated drop handler for folders ***
            figuresFilesDropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                figuresFilesDropZone.classList.remove('drag-over');
                
                let files = [];
                if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                    // Use new helper function to get files from folders
                    files = await getFilesFromDrop(e.dataTransfer.items);
                } else if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    // Fallback for older browsers (no folder support)
                    files = Array.from(e.dataTransfer.files);
                }
                handleFigureFiles(files);
            });

            // *** MODIFIED: Input change handler now handles folder input ***
            figuresFilesInput.addEventListener('change', (e) => {
                // Files from <input type="file" webkitdirectory>
                // already have webkitRelativePath
                handleFigureFiles(e.target.files);
            });

            function handleFile(file) {
                originalFileName = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalTexContent = e.target.result;
                    processTexFile();
                    document.getElementById('figuresFileName').textContent = file.name;
                    fileInfo.classList.add('visible');
                };
                reader.readAsText(file);
            }

            function removeComments(texContent) {
                const lines = texContent.split('\n');
                const cleanedLines = lines.map(line => {
                    let cleanedLine = '';
                    for (let i = 0; i < line.length; i++) {
                        if (line[i] === '%' && (i === 0 || line[i-1] !== '\\')) break;
                        cleanedLine += line[i];
                    }
                    return cleanedLine;
                });
                return cleanedLines.join('\n');
            }

            function processTexFile() {
                mappings = [];
                let figureNumber = 0;
                const cleanedContent = removeComments(originalTexContent);
                const figureRegex = /\\begin\{figure\}.*?\\end\{figure\}/gs;
                const figures = cleanedContent.match(figureRegex) || [];

                figures.forEach((figure) => {
                    figureNumber++;
                    const includeRegex = /\\includegraphics(?:\[.*?\])?\s*\{([^}]+)\}/g;
                    const images = [];
                    let match;
                    
                    while ((match = includeRegex.exec(figure)) !== null) {
                        images.push(match[1]);
                    }

                    if (images.length === 1) {
                        const oldPath = images[0];
                        const ext = oldPath.substring(oldPath.lastIndexOf('.'));
                        const newName = `Fig${figureNumber}${ext}`;
                        const newPathWithFolder = `./Figures_ordered/${newName}`;
                        mappings.push({ old: oldPath, new: newName, newPath: newPathWithFolder });
                    } else if (images.length > 1) {
                        images.forEach((oldPath, index) => {
                            const ext = oldPath.substring(oldPath.lastIndexOf('.'));
                            const letter = String.fromCharCode(97 + index);
                            const newName = `Fig${figureNumber}-${letter}${ext}`;
                            const newPathWithFolder = `./Figures_ordered/${newName}`;
                            mappings.push({ old: oldPath, new: newName, newPath: newPathWithFolder });
                        });
                    }
                });

                updatedTexContent = originalTexContent;
                mappings.forEach(mapping => {
                    // Normalize slashes in mapping.old for regex
                    const normalizedOldPath = mapping.old.replace(/\\/g, '/');
                    const escapedOld = normalizedOldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    
                    // Create a regex that finds the path, insensitive to slash type
                    // This matches {path/to/file} or {path\to\file}
                    const regex = new RegExp(`\\{${escapedOld.replace(/\\\//g, '[\\\\/]')}\\}`, 'g');
                    updatedTexContent = updatedTexContent.replace(regex, `{${mapping.newPath}}`);
                });

                displayResults();
            }

            function displayResults() {
                const uniqueFigures = new Set(mappings.map(m => {
                    const match = m.new.match(/Fig(\d+)/);
                    return match ? match[1] : null;
                }).filter(Boolean));
                
                document.getElementById('figureCount').textContent = uniqueFigures.size;
                document.getElementById('imageCount').textContent = mappings.length;

                const mappingList = document.getElementById('mappingList');
                mappingList.innerHTML = '';

                if (mappings.length === 0) {
                    mappingList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">No figures found in the document</div>';
                } else {
                    mappings.forEach(mapping => {
                        const item = document.createElement('div');
                        item.className = 'mapping-item';
                        item.innerHTML = `
                            <div class="old-name">${mapping.old}</div>
                            <div class="arrow">‚Üí</div>
                            <div class="new-name">${mapping.newPath}</div>
                        `;
                        mappingList.appendChild(item);
                    });
                }

                results.classList.add('visible');
                figuresDropSection.classList.add('visible');
            }

            function handleFigureFiles(files) {
                // The 'files' here is a FileList or an Array of File objects
                // The File objects should have .webkitRelativePath
                droppedFiles = Array.from(files); 
                displayDroppedFiles();
                downloadZipButton.disabled = droppedFiles.length === 0;
            }

            function displayDroppedFiles() {
                droppedFilesList.innerHTML = '';
                
                droppedFiles.forEach(file => {
                    // *** MODIFIED: Use webkitRelativePath for matching ***
                    // Ensure file.webkitRelativePath exists; fallback to name
                    let fileRelativePath = (file.webkitRelativePath || file.name);
                    fileRelativePath = fileRelativePath.replace(/\\/g, '/'); // Normalize slashes
                    
                    const item = document.createElement('div');
                    
                    // Try to match with mappings
                    const mapping = mappings.find(m => {
                        // Normalize mapping.old as well for comparison
                        const normalizedOldPath = m.old.replace(/\\/g, '/');
                        // Check if the file's full relative path ENDS WITH the path from the .tex file
                        // This handles "figures/img.png" matching "my_project/figures/img.png"
                        return fileRelativePath.endsWith(normalizedOldPath);
                    });
                    
                    item.className = `file-item ${mapping ? 'matched' : 'unmatched'}`;
                    
                    if (mapping) {
                        item.innerHTML = `
                            <span class="status">‚úÖ</span>
                            <span>${fileRelativePath} ‚Üí ${mapping.new}</span>
                        `;
                    } else {
                        item.innerHTML = `
                            <span class="status">‚ö†Ô∏è</span>
                            <span>${fileRelativePath} (not found in .tex)</span>
                        `;
                    }
                    
                    droppedFilesList.appendChild(item);
                });
            }

            downloadZipButton.addEventListener('click', async () => {
                const zip = new JSZip();
                const folder = zip.folder('Figures_ordered');
                
                let matchedCount = 0;
                
                for (const file of droppedFiles) {
                    // *** MODIFIED: Use webkitRelativePath for matching ***
                    let fileRelativePath = (file.webkitRelativePath || file.name);
                    fileRelativePath = fileRelativePath.replace(/\\/g, '/');
                    
                    const mapping = mappings.find(m => {
                        const normalizedOldPath = m.old.replace(/\\/g, '/');
                        return fileRelativePath.endsWith(normalizedOldPath);
                    });
                    
                    if (mapping) {
                        // We add the file to the zip with its NEW name
                        folder.file(mapping.new, file); 
                        matchedCount++;
                    }
                }
                
                if (matchedCount === 0) {
                    alert('No dropped files matched the mappings from your .tex file!');
                    return;
                }
                
                downloadZipButton.disabled = true;
                downloadZipButton.innerHTML = '<span>‚è≥</span><span>Creating ZIP...</span>';
                
                try {
                    const content = await zip.generateAsync({type: 'blob'});
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'Figures_ordered.zip';
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    downloadZipButton.innerHTML = '<span>‚úÖ</span><span>Downloaded!</span>';
                    setTimeout(() => {
                        downloadZipButton.innerHTML = '<span>üì¶</span><span>Download Renamed Figures (ZIP)</span>';
                        downloadZipButton.disabled = false;
                    }, 2000);
                } catch (error) {
                    alert('Error creating ZIP file: ' + error.message);
                    downloadZipButton.innerHTML = '<span>üì¶</span><span>Download Renamed Figures (ZIP)</span>';
                    downloadZipButton.disabled = false;
                }
            });

            document.getElementById('downloadTex').addEventListener('click', () => {
                const blob = new Blob([updatedTexContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = originalFileName.replace('.tex', '_ordered.tex');
                a.click();
                URL.revokeObjectURL(url);
            });

            document.getElementById('downloadBash').addEventListener('click', () => {
                let bashScript = '#!/bin/bash\n\n';
                bashScript += '# LaTeX Figure Organization Script\n';
                bashScript += '# This script COPIES files to Figures_ordered folder\n\n';
                bashScript += 'OUTPUT_DIR="Figures_ordered"\n\n';
                bashScript += 'mkdir -p "$OUTPUT_DIR"\n';
                bashScript += 'echo "üìÅ Created directory: $OUTPUT_DIR"\n\n';
                bashScript += 'SUCCESS_COUNT=0\nSKIP_COUNT=0\nERROR_COUNT=0\n\n';

                mappings.forEach((mapping) => {
                    const destFile = `$OUTPUT_DIR/${mapping.new}`;
                    // Use a find command to locate the file, in case it's in a subdirectory
                    // This is a robust way to handle the relative paths
                    bashScript += `SRC_FILE=$(find . -path "*/${mapping.old}" -print -quit)\n`
                    bashScript += `if [ -n "$SRC_FILE" ] && [ -f "$SRC_FILE" ]; then\n`;
                    bashScript += `    if [ -f "${destFile}" ]; then\n`;
                    bashScript += `        echo "‚≠ïÔ∏è Skipped (exists): ${destFile}"\n`;
                    bashScript += `        SKIP_COUNT=$((SKIP_COUNT + 1))\n`;
                    bashScript += `    else\n`;
                    bashScript += `        cp "$SRC_FILE" "${destFile}"\n`;
                    bashScript += `        echo "‚úÖ $SRC_FILE -> ${destFile}"\n`;
            
                    bashScript += `        SUCCESS_COUNT=$((SUCCESS_COUNT + 1))\n`;
                    bashScript += `    fi\n`;
                    bashScript += `else\n`;
                    bashScript += `    echo "‚ùå Not found: ${mapping.old}"\n`;
                    bashScript += `    ERROR_COUNT=$((ERROR_COUNT + 1))\n`;
                    bashScript += `fi\n\n`;
                });

                bashScript += 'echo "---"\n';
                bashScript += 'echo "‚úÖ Copied: $SUCCESS_COUNT | ‚≠ïÔ∏è Skipped: $SKIP_COUNT | ‚ùå Errors: $ERROR_COUNT"\n';

                const blob = new Blob([bashScript], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'organize_figures.sh';
                a.click();
                URL.revokeObjectURL(url);
            });
        })();

        // ===== BIBTEX FORMATTER SCRIPT =====
        (function() {
            const JOURNAL_ABBREV = {
                'Computational Materials Science': 'Comput. Mater. Sci.',
                'Acta Materialia': 'Acta Mater.',
                'International Journal of Plasticity': 'Int. J. Plast.',
                'Materials transactions': 'Mater. Trans.',
                'Journal of the Mechanics and Physics of Solids': 'J. Mech. Phys. Solids',
                'Journal of Applied Mechanics': 'J. Appl. Mech.',
                'Philosophical Magazine': 'Philos. Mag.',
                'Progress in Materials Science': 'Prog. Mater. Sci.',
                'Computer methods in applied mechanics and engineering': 'Comput. Methods Appl. Mech. Eng.',
                'Acta metallurgica': 'Acta Metall.',
                'Physical Review Materials': 'Phys. Rev. Mater.',
                'Scripta Materialia': 'Scr. Mater.',
                'Materials Science and Engineering: A': 'Mater. Sci. Eng. A',
                'Materials Science and Engineering: R: Reports': 'Mater. Sci. Eng. R',
                'Journal of Materials Science': 'J. Mater. Sci.',
                'Metallurgical and Materials Transactions A': 'Metall. Mater. Trans. A',
                'Physical Review Letters': 'Phys. Rev. Lett.',
                'Nature Materials': 'Nat. Mater.',
                'Science': 'Science',
                'Nature': 'Nature',
                'Physical Review B': 'Phys. Rev. B',
                'Advances in physics': 'Adv. Phys.',
                'Comptes rendus. Physique': 'C. R. Phys.',
                'Journal of Physics D: Applied Physics': 'J. Phys. D Appl. Phys.',
                'Nature Communications': 'Nat. Commun.',
                'Modelling and Simulation in Materials Science and Engineering': 'Model. Simul. Mater. Sci. Eng.',
                'Materials Theory': 'Mater. Theor.',
                'Mechanics of Nano-objects': 'Mech. Nano-obj.',
                // --- Added Journals ---
                'Advanced Materials': 'Adv. Mater.',
                'Advanced Functional Materials': 'Adv. Funct. Mater.',
                'Nano Letters': 'Nano Lett.',
                'ACS Nano': 'ACS Nano',
                'Journal of Materials Research': 'J. Mater. Res.',
                'Applied Physics Letters': 'Appl. Phys. Lett.',
                'Journal of Applied Physics': 'J. Appl. Phys.',
                'International Journal of Solids and Structures': 'Int. J. Solids Struct.',
                'Engineering Fracture Mechanics': 'Eng. Fract. Mech.',
                'Composites Science and Technology': 'Compos. Sci. Technol.',
                'Composite Structures': 'Compos. Struct.',
                'Journal of Computational Physics': 'J. Comput. Phys.',
                'Annual Review of Materials Research': 'Annu. Rev. Mater. Res.',
                'Proceedings of the National Academy of Sciences': 'Proc. Natl. Acad. Sci. U.S.A.',
                'Physical Review Applied': 'Phys. Rev. Appl.',
                'Extreme Mechanics Letters': 'Extreme Mech. Lett.',
                'npj Computational Materials': 'npj Comput. Mater.',
                'Mechanics of Materials': 'Mech. Mater.'
            };

            let currentFile = null;
            let currentContent = null;

            const dropZone = document.getElementById('bibtexDropZone');
            const fileInput = document.getElementById('bibtexFileInput');
            const processButton = document.getElementById('bibtexProcessButton');
            const status = document.getElementById('bibtexStatus');
            const preview = document.getElementById('bibtexPreview');
            const statsDiv = document.getElementById('bibtexStats');

            if (!dropZone) {
                console.error("BibTeX Drop zone not found.");
                return;
            }

            dropZone.addEventListener('click', () => fileInput.click());
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) handleFile(files[0]);
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) handleFile(e.target.files[0]);
            });
            
            processButton.addEventListener('click', processFile);
            
            function handleFile(file) {
                const ext = file.name.split('.').pop().toLowerCase();
                if (ext !== 'bib' && ext !== 'bbl') {
                    showStatus('Please select a .bib or .bbl file', 'error');
                    return;
                }
                
                currentFile = file;
                const reader = new FileReader();
                reader.onload = (e) => {
                    currentContent = e.target.result;
                    processButton.disabled = false;
                    dropZone.querySelector('.drop-zone-text').textContent = `File loaded: ${file.name}`;
                    showStatus('File loaded! Click "Process File" to continue.', 'success');
                };
                reader.readAsText(file);
            }

            function abbreviateJournal(journalName) {
                const clean = journalName.replace(/[{}]/g, '').trim().toLowerCase();
                for (const [full, abbrev] of Object.entries(JOURNAL_ABBREV)) {
                    if (full.toLowerCase() === clean) return abbrev;
                }
                return journalName.replace(/[{}]/g, '').trim();
            }

            function processFile() {
                if (!currentContent || !currentFile) return;
                
                const options = {
                    abbreviateAuthors: document.getElementById('abbreviateAuthors').checked,
                    abbreviateJournals: document.getElementById('abbreviateJournals').checked,
                    removeDuplicates: document.getElementById('removeDuplicates').checked
                };
                
                const ext = currentFile.name.split('.').pop().toLowerCase();
                const stats = { authorsProcessed: 0, journalsProcessed: 0, duplicatesRemoved: 0 };
                let result = currentContent;

                if (options.abbreviateAuthors) {
                    const replacements = [];
                    const authorRegex = /author\s*=\s*\{/gi;
                    let match;
                    
                    while ((match = authorRegex.exec(result)) !== null) {
                        const startPos = match.index;
                        const contentStart = startPos + match[0].length;
                        
                        let depth = 1;
                        let pos = contentStart;
                        
                        while (pos < result.length && depth > 0) {
                            const char = result[pos];
                            
                            if (char === '{') {
                                depth++;
                            } else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    break;
                                }
                            }
                            
                            pos++;
                        }
                        
                        const authorContent = result.substring(contentStart, pos);
                        const formatted = formatAuthors(authorContent);
                        
                        replacements.push({
                            start: startPos,
                            end: pos + 1,
                            text: `author = {${formatted}}`
                        });
                    }
                    
                    replacements.sort((a, b) => b.start - a.start);
                    replacements.forEach(rep => {
                        result = result.substring(0, rep.start) + rep.text + result.substring(rep.end);
                    });
                    
                    stats.authorsProcessed = replacements.length;
                }

                if (options.abbreviateJournals) {
                    const replacements = [];
                    const journalRegex = /journal\s*=\s*\{/gi;
                    let match;
                    
                    while ((match = journalRegex.exec(result)) !== null) {
                        const startPos = match.index;
                        const contentStart = startPos + match[0].length;
                        
                        let depth = 1;
                        let pos = contentStart;
                        
                        while (pos < result.length && depth > 0) {
                            const char = result[pos];
                            
                            if (char === '{') {
                                depth++;
                            } else if (char === '}') {
                                depth--;
                                if (depth === 0) {
                                    break;
                                }
                            }
                            
                            pos++;
                        }
                        
                        const journalContent = result.substring(contentStart, pos);
                        const abbrev = abbreviateJournal(journalContent);
                        
                        if (abbrev !== journalContent.replace(/[{}]/g, '').trim()) {
                            stats.journalsProcessed++;
                        }
                        
                        replacements.push({
                            start: startPos,
                            end: pos + 1,
                            text: `journal = {${abbrev}}`
                        });
                    }
                    
                    replacements.sort((a, b) => b.start - a.start);
                    replacements.forEach(rep => {
                        result = result.substring(0, rep.start) + rep.text + result.substring(rep.end);
                    });
                }
                
                showStats(stats);
                showPreview(result);
                downloadFile(result, ext);
                showStatus(`‚úì Processing complete! ${stats.authorsProcessed} authors and ${stats.journalsProcessed} journals formatted.`, 'success');
            }
            
            function showStats(stats) {
                statsDiv.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-value">${stats.authorsProcessed}</div>
                        <div class="stat-label">Authors Formatted</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.journalsProcessed}</div>
                        <div class="stat-label">Journals Abbreviated</div>
                    </div>
                `;
                statsDiv.style.display = 'flex';
            }
            
            function showPreview(content) {
                preview.textContent = content.substring(0, 1000) + '\n\n... (showing first 1000 characters)';
                preview.style.display = 'block';
            }
            
            function showStatus(message, type) {
                status.textContent = message;
                status.className = `status ${type}`;
            }
            
            function downloadFile(content, ext) {
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFile.name.replace(`.${ext}`, `_formatted.${ext}`);
                a.click();
                URL.revokeObjectURL(url);
            }
        })();

        // Run tests on page load
        setTimeout(runTests, 100);
        
    }); // <-- End of DOMContentLoaded
    </script>
</body>
</html>